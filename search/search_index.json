{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"mahsm: A Declarative Framework for Building Production-Grade AI Systems","text":"<p>mahsm (Multi-Agent Hyper-Scaling Methods) is a unified, declarative framework designed to streamline the entire lifecycle of building, observing, and evaluating sophisticated multi-agent AI systems.</p> <p>It addresses the core challenge in modern AI development: the immense boilerplate and friction involved in wiring together state-of-the-art tools for reasoning, orchestration, tracing, and testing.</p> <p>By providing a cohesive, high-level API, <code>mahsm</code> allows developers to focus on the logic of their agents, not the plumbing. The result is a development workflow that is faster, more robust, and produces systems that are observable and testable by default.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Declarative by Design: Say goodbye to glue code. Declare your system's components, and <code>mahsm</code> handles the integration.</li> <li>Best-in-Class Tooling: A seamless fusion of DSPy, LangGraph, LangFuse, and EvalProtocol.</li> <li>Zero-Effort Observability: Get deep, hierarchical traces automatically with a single line of code.</li> <li>Testable by Default: A built-in testing harness makes evaluating your agents a first-class citizen of the development process.</li> </ul> <p>Getting Started View on GitHub</p>"},{"location":"concepts/declarative-design/","title":"Declarative by Design","text":"<p>The central philosophy of <code>mahsm</code> is its declarative approach. Instead of manually writing imperative \"glue code\" to connect different libraries, you declare the components of your system, and <code>mahsm</code> handles the integration and boilerplate.</p> <p>This \"convention over configuration\" approach is designed to let you focus entirely on your agent's business logic, not the plumbing.</p>"},{"location":"concepts/declarative-design/#the-mahsm-approach","title":"The <code>mahsm</code> Approach","text":"<ul> <li>You declare your agent's reasoning by writing standard <code>dspy.Module</code> classes. The powerful <code>@ma.dspy_node</code> decorator instantly makes them compatible with the orchestration layer.</li> <li>You declare your workflow's structure by adding your nodes to a <code>ma.graph.StateGraph</code> and defining the edges between them.</li> <li>You declare your evaluation criteria by configuring the <code>ma.testing.PytestHarness</code> to run your graph against a dataset.</li> </ul>"},{"location":"concepts/declarative-design/#the-benefits","title":"The Benefits","text":"<p>This philosophy drastically reduces boilerplate, improves code readability, and embeds best practices for observability and testing directly into the development process. The result is a workflow that is faster, more robust, and produces systems that are understandable by default.</p>"},{"location":"concepts/four-pillars/","title":"The Four Pillars of <code>mahsm</code>","text":"<p><code>mahsm</code> achieves its power by deeply integrating four essential, best-in-class libraries into a single, seamless experience. All functionality is exposed through the unified <code>import mahsm as ma</code> API, giving you a consistent and clean developer experience.</p>"},{"location":"concepts/four-pillars/#1-dspy-the-reasoning-engine-madspy","title":"1. DSPy: The Reasoning Engine (<code>ma.dspy</code>)","text":"<ul> <li>What it is: A framework from Stanford NLP for programming\u2014not just prompting\u2014language models. It separates program flow from parameters (prompts and model weights) and uses optimizers to tune them for maximum performance.</li> <li>How <code>mahsm</code> Fuses it: <code>mahsm</code> treats DSPy modules as the fundamental building blocks of agent intelligence. The core innovation is the <code>@ma.dspy_node</code> decorator. This tool instantly transforms any <code>dspy.Module</code> into a fully compliant LangGraph node, automatically handling the complex mapping of data from the shared graph <code>State</code> to the module's inputs and back.</li> </ul>"},{"location":"concepts/four-pillars/#2-langgraph-the-orchestration-scaffolding-magraph","title":"2. LangGraph: The Orchestration Scaffolding (<code>ma.graph</code>)","text":"<ul> <li>What it is: A library for building stateful, multi-agent applications by representing them as cyclical graphs. It provides the primitives of <code>State</code>, <code>Nodes</code>, and <code>Edges</code> to create complex, long-running agentic workflows.</li> <li>How <code>mahsm</code> Fuses it: LangGraph provides the skeleton, and <code>mahsm</code> provides the intelligent organs. By making DSPy modules the primary type of \"thinking\" node, <code>mahsm</code> supercharges LangGraph development. You define your application's <code>State</code> and use <code>ma.graph.StateGraph</code> to wire together your <code>@ma.dspy_node</code> agents.</li> </ul>"},{"location":"concepts/four-pillars/#3-langfuse-the-unified-observability-layer","title":"3. LangFuse: The Unified Observability Layer","text":"<ul> <li>What it is: A comprehensive open-source platform for LLM observability, providing detailed tracing, debugging, and analytics for AI applications.</li> <li>How <code>mahsm</code> Fuses it: <code>mahsm</code> makes deep, hierarchical tracing an automatic, zero-effort feature. The single <code>ma.init()</code> function simultaneously instruments both LangGraph and DSPy. When you run your graph, <code>mahsm</code> creates a single, unified trace in LangFuse that captures both the high-level graph flow and the low-level DSPy execution details (prompts, tool calls, etc.), solving the massive pain point of achieving end-to-end observability.</li> </ul>"},{"location":"concepts/four-pillars/#4-evalprotocol-the-quality-control-testing-framework-matesting","title":"4. EvalProtocol: The Quality Control &amp; Testing Framework (<code>ma.testing</code>)","text":"<ul> <li>What it is: A standardized, <code>pytest</code>-based framework for evaluating the performance of AI systems using LLM-as-a-judge and other metrics.</li> <li>How <code>mahsm</code> Fuses it: <code>mahsm</code> bridges the gap between your built application and your test suite. The <code>ma.testing.PytestHarness</code> class radically simplifies setup by automatically generating the boilerplate processors required by <code>eval-protocol</code>. The harness can even pull evaluation datasets directly from your production LangFuse traces, enabling a tight, continuous loop of deploying, observing, and evaluating your system's real-world performance.</li> </ul>"},{"location":"concepts/workflow/","title":"The <code>mahsm</code> Development Workflow","text":"<p>Developing with <code>mahsm</code> follows a simple, iterative, and powerful three-step loop: Build, Trace, and Evaluate. This cycle is designed to be fast and data-driven, ensuring you are creating high-quality, robust systems.</p> <p> </p>"},{"location":"concepts/workflow/#1-build","title":"1. Build","text":"<p>This is the core development step where you write idiomatic <code>mahsm</code> code. - Define State: Create a <code>TypedDict</code> that represents the shared state of your application. - Create Nodes: Write <code>dspy.Module</code> classes to encapsulate the reasoning logic for your agents. Decorate them with <code>@ma.dspy_node</code>. - Wire Graph: Add your nodes to a <code>ma.graph.StateGraph</code> and define the edges to control the flow of execution. - Compile: Call <code>.compile()</code> on your graph to create the runnable application.</p>"},{"location":"concepts/workflow/#2-trace","title":"2. Trace","text":"<p>Once built, you run your application.     *   With <code>ma.init()</code> called at the start of your script, every execution is automatically and deeply traced in LangFuse.     *   You use the LangFuse UI to inspect the full decision-making process of your agent, debug issues, understand latency, and analyze token usage.     *   You can tag interesting traces to save them as examples for regression testing or for creating evaluation datasets.</p>"},{"location":"concepts/workflow/#3-evaluate","title":"3. Evaluate","text":"<p>Finally, you verify the quality of your agent's output.     *   Write a Test File: Create a standard <code>pytest</code> file.     *   Configure the Harness: Use the <code>ma.testing.PytestHarness</code> to connect your compiled <code>mahsm</code> graph to the evaluation protocol.     *   Run Eval: Use datasets (potentially generated from your production traces in LangFuse) to run an evaluation.     *   Analyze &amp; Iterate: Use the evaluation leaderboards and results to identify weaknesses in your agent's logic, then go back to the BUILD step to improve it.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Getting <code>mahsm</code> installed is quick and easy. We recommend using a virtual environment to manage your project's dependencies.</p>"},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9+</li> <li><code>uv</code> (or <code>pip</code>) package installer</li> </ul>"},{"location":"getting-started/installation/#installing-mahsm","title":"Installing <code>mahsm</code>","text":"<p>To install the core <code>mahsm</code> library, run the following command:</p> <pre><code>uv pip install mahsm\n</code></pre> <p>This will install mahsm and its core dependencies, including DSPy, LangGraph, LangFuse, and EvalProtocol.</p>"},{"location":"getting-started/installation/#setting-up-observability-langfuse","title":"Setting Up Observability (LangFuse)","text":"<p>One of the core features of mahsm is its deep integration with LangFuse for observability. To enable it, you need to set the following environment variables: <pre><code>export LANGFUSE_PUBLIC_KEY=\"pk-lf-...\"\nexport LANGFUSE_SECRET_KEY=\"sk-lf-...\"\nexport LANGFUSE_HOST=\"https://cloud.langfuse.com\" # Or your self-hosted instance\n</code></pre></p> <p>You can find your keys in your LangFuse project settings.</p>"},{"location":"getting-started/quickstart/","title":"Quickstart: Building Your First <code>mahsm</code> Agent","text":"<p>Let's build a simple research agent to see how the core components of <code>mahsm</code> work together. This example demonstrates the declarative nature of the framework.</p>"},{"location":"getting-started/quickstart/#1-the-single-import","title":"1. The Single Import","text":"<p>All of <code>mahsm</code>'s fused functionality is available through the top-level <code>ma</code> import.</p> <pre><code>import mahsm as ma\nfrom typing import TypedDict, Optional\n</code></pre>"},{"location":"getting-started/quickstart/#2-define-the-shared-state","title":"2. Define the Shared State","text":"<p>The State is a TypedDict that defines the data structure that flows through your graph. Every node can read from and write to this state.</p> <pre><code>class AgentState(TypedDict):\n    input_query: str\n    research_result: Optional[str]\n</code></pre>"},{"location":"getting-started/quickstart/#3-create-a-reasoning-node-with-madspy_node","title":"3. Create a Reasoning Node with @ma.dspy_node","text":"<p>Here, we define the \"brain\" of our agent using a <code>dspy.Module</code>. The <code>@ma.dspy_node</code> decorator is the magic that makes this module compatible with the LangGraph orchestrator, automatically handling data mapping from the AgentState.</p> <pre><code>@ma.dspy_node\nclass Researcher(ma.Module):\n    def __init__(self):\n        super().__init__()\n        self.signature = \"input_query -&gt; research_result\"\n        self.predictor = ma.dspy.ChainOfThought(self.signature)\n\n    def forward(self, input_query):\n        return self.predictor(input_query=input_query)\n</code></pre>"},{"location":"getting-started/quickstart/#4-build-and-compile-the-graph","title":"4. Build and Compile the Graph","text":"<p>Finally, we use <code>ma.graph.StateGraph</code> to define the workflow. We add our <code>Researcher</code> node and define the edges that control the flow of execution.</p> <pre><code># Initialize the graph with our state definition\nworkflow = ma.graph.StateGraph(AgentState)\n\n# Add the DSPy-powered node\nworkflow.add_node(\"researcher\", Researcher())\n\n# Define the workflow structure\nworkflow.add_edge(ma.START, \"researcher\")\nworkflow.add_edge(\"researcher\", ma.END)\n\n# Compile the graph into a runnable application\ngraph = workflow.compile()\n</code></pre>"},{"location":"getting-started/quickstart/#5-run-and-trace","title":"5. Run and Trace","text":"<p>To run your agent, simply invoke the graph. If you've called ma.init() beforehand, the entire execution will be traced in LangFuse automatically.</p> <pre><code># Initialize tracing (do this once at the start of your app)\nma.init()\n\n# Run the graph\ninputs = {\"input_query\": \"What is the future of multi-agent AI systems?\"}\nresult = graph.invoke(inputs)\n\nprint(result['research_result'])\n</code></pre> <p>That's it! You've built a fully observable and testable agent with minimal boilerplate, focusing only on the essential logic.</p>"}]}